\chapter{Cycle 2: Project Management}
\graphicspath{{figures}}


\section{Brief Outline}
    This cycle will cover initialising and opening ``projects'', which will be how the user will be able to save their work and access it at a later time. 

    % for:hierarchy_diagram_c2
    % Cycle 2 Hierarchy diagram
    \begin{figure}[!ht]
        \centering
        \footnotesize
        \begin{forest}
            for tree={
                align=center,
                font=\sffamily,
            edge+={thick, -{Stealth[]}},
            l sep'+=10pt,
            fork sep'=10pt,
            },
            forked edges,
            if level=0{
                inner xsep=0pt,
                tikz={\draw [thick] (.children first) -- (.children last);}
                }{},
                [Project Management
                    [Opening projects
                        [Choosing working\\directory]
                        [Verifying files]
                    ]
                    [Initialising projects
                        [Initialising files]
                        [Choosing working\\directory
                            [Naming projects]
                        ]
                    ]
                ]
        \end{forest}
        \caption{Cycle 2 hierarchy diagram}
        \label{for:hierarchy_diagram_c2}
    \end{figure}

    
    \subsection{Success Criteria}
        See \autoref{tbl:succ-crit-c2}.

\section{Design}
    % The general idea is that it will use one program (this is the same one that the installer creates a shortcut to).
    % From then the user will be able to choose whether to open a new or existing project
    % If an existing project then the user will navigate to the project file inside the project folder, select it, and then it will use that to open everything necessary
    % If a new project then the user will select the DIRECTORY where they want the project file to be in. They will also decide on a name. I might also decide to include a drop down menu to select some kind of "type" or something.

    The idea of this cycle is that it will use one program, which is the one that the installer creates a shortcut to, from which the user will be able to decide whether to open a new or existing project. 
    If the user chooses the former, then they will be prompted to select the \textit{directory} in which they would like to initialise their project, and if the latter then they will be prompted to select the \textit{project file} for their project. 
    The user will initially start on one user interface screen and depending on their choice go to one of two other user interface screens.

    \subsection{Data Structures}
    
        A data structure that allows the user to select their most recent projects from a list will need to be designed, as a consequence of the user interface design shown in \autoref{fig:menu_1_design_c2}.
        This data structure will need to be First In First Out, similar to a queue, however I would like it to only hold a maximum of three items. 
        See \autoref{flow:queue_like_design} for details.

        % flow:queue_like_design
        % Design for the queue-like data structure
        \begin{figure}[!ht]
            \centering
            \begin{tikzpicture}[node distance=2cm]
                \node (2) [process, align=center] {B};
                \node (1) [process, left of=2,  align=center, xshift=-2.0cm] {A};
                \node (3) [process, right of=2, align=center, xshift=2.0cm] {C};

                \node (4) [process, below of=1, align=center, ] {A};
                \node (5) [process, below of=2, align=center, ] {B};
                \node (6) [process, below of=3, align=center, ] {C};
                \node (7) [process, right of=6, align=center, xshift=2.0cm] {D (New item)};

                \node (8) [process, below of=5, align=center, ] {B};
                \node (9) [process, below of=6, align=center, ] {C};
                \node (10) [process, below of=7, align=center, ] {D};

                \draw [arrow] (2) -- (1);
                \draw [arrow] (3) -- (2);
                \draw [darrow] (5) -- (4);
                \draw [arrow] (6) -- (5);
                \draw [arrow] (7) -- (6);
                \draw [arrow] (9) -- (8);
                \draw [arrow] (10) -- (9);
            \end{tikzpicture}
            \caption{How the queue-like structure will operate. Arrows point to the next oldest item.}
            \label{flow:queue_like_design}
        \end{figure}

        This structure will be implemented with the use of a `global' text file (in the sense that changes to the text file on a local scale are reflected for every project) that will store projects in order of being opened.

        % fig:file-q-class-diagram
        % FileQueue class diagram
        \begin{figure}[!ht]
            \centering
            \begin{tikzpicture}
                \begin{class}[text width=5cm]{FileQueue}{0,0}
                    \attribute{-location : string}
                    \attribute{-maxLength : int}
                    \attribute{-rear : int}
                    \attribute{-front : int}


                    \operation{+enqueue(string)}
                    \operation{+dequeue(): string}
                    \operation{+length(): int}
                    \operation{+drop(): list}

                    \operation{+getRear(): int}
                    \operation{+getFront(): int}
                \end{class}
            \end{tikzpicture}
            \caption{FileQueue class diagram}
            \label{fig:file-q-class-diagram}
        \end{figure}

        This class will allow me to easily access the FileQueue for the user's projects. 

        % dir:project_directory_tree_example_c2
        % Directory tree for an example project
        \begin{figure}[!ht]
            \centering
            \begin{forest}
                pic dir tree,
                pic root,
                for tree={% folder icons by default; override using file for file icons
                    directory,
                },
                [project-name
                    [arrangements.json, file
                    ]
                    [config.json, file
                    ]
                ]
            \end{forest}
            \caption{Directory tree example}
            \label{dir:project_directory_tree_example_c2}
        \end{figure}

        % USed JSON cause it was easier
        % Didnt use SQL/database because i dont need them to be connected in any way and there is only a small amount of data involved


        Each directory that contains a project will include a configuration JSON file that will inform the main program on how to treat the project. 
        I have decided to use JSON as it integrates nicely with Python (using the JSON module), as well as allowing me to create a template that each project can follow. 


        As shown in \autoref{ps:json-proj-config-example}, multiple properties regarding the project will be stored. 
        Some of these will be set at the beginning and not changed again, such as \verb|directory|, and others are able to change even after the project's initial creation, in particular \verb|last_opened| will need to updated whenever the project is opened. 
        Note that double backwards slashes are used for the \verb|directory| attribute, as a backwards slash is used as an escape character in the JSON file format.

        % ps:json-proj-config-example
        % Example for the JSON config file for a project
        \begin{figure}[!ht]
            \begin{minted}[linenos]{json}
{
    "directory": "C:\\users\\...",
    "name": "this is a project name",
    "type": "project type",
    "created": "UNIX timestamp",
    "lastSaved": "UNIX timestamp"
}
            \end{minted}
            \caption{Configuration JSON file example}
            \label{ps:json-proj-config-example}
        \end{figure}


        In \autoref{dir:project_directory_tree_example_c2}, I have designed the file structure for a single project. 
        The \verb|arrangements.json| file will hold how the components are arranged on the board. This is what the main program will use to run. 
        See \autoref{ps:json-proj-config-example} for the layout of \verb|config.json|.


        % fig:project-class-diagram-c2
        % Project class diagram
        \begin{figure}[!ht]
            \centering
            \begin{tikzpicture}
                \begin{class}[text width=5cm]{Project}{0,0}
                    \attribute{-name : string}
                    \attribute{-created : int}
                    \attribute{-lastOpened : int}
                    \attribute{-type : string}
                    \attribute{-directory : string}
                    \attribute{-config : string}

                    \operation{+save()}
                    \operation{+export(string)}
                    \operation{+open()}
                    \operation{+close()}

                    \operation{+setName(string)}
                    \operation{+setLastOpened(int)}
                \end{class}
            \end{tikzpicture}
            \caption{Project class diagram}
            \label{fig:project-class-diagram-c2}
        \end{figure}

        I have again decided to make use of object-oriented programming this time in order to have a class for an instance of a running program, a class diagram of which is shown in \autoref{fig:project-class-diagram-c2}.

    \subsection{User Interface} 
        % Need to design 3 UI windows. 
        % One initial one that will then decide to go into one of the other two 

        % The initial one only needs two options, but something like a "recently viewed" might be nice.
        % It also will need a cancel option.

        % If user decides to open existing project, then need a browse directory button, as well as a confirm button. I don't think it needs anything more than that.
        % I think this could have a dropdown that could open a template 
        
        % If user decides to open new project, then need a "Name" entry, as well as a directory entry. Also confirm and cancel buttons. 

        There will be three user-interface menus covered in this section, one for where the user decides to open a new or existing project, and one each for actually selecting the project they want to open/create. 
        This was mainly inspired by the user-interface from Visual Studio 2022, see \autoref{fig:vs22_ui_ss_c2}, which shows a minimal design with only the necessary features shown.
        The layout is also very user-friendly, with large clear buttons shown as well as recently opened/viewed projects.

        % fig:vs22_ui_ss_c2
        % Screenshot from visual studio 22 that shows the UI for opening a project
        \begin{figure}[!ht]
            \centering
            \includegraphics[width=.7\textwidth]{s04/design/vscode22.png}
            \caption{Screenshot from Visual Studio 2022}
            \label{fig:vs22_ui_ss_c2}
        \end{figure}

        With the colour-scheme, I have decided to stay consistent with my user interface from Cycle 1. The colours, borders, and fonts are the same. 
        I have decided to follow a similar layout to the one shown in \autoref{fig:vs22_ui_ss_c2}, but I chose to only have buttons for the three most recently viewed projects, as opposed to all of them sorted by date. 
        If the user has yet to open three projects, then the others would be greyed out and the user would not be able to click on them. 
        The justification for only showing three is that it could be difficult to implement an embedded window that allows the user to scroll through it independently of the rest of the window, and that the user will likely not be working on more than three at a time. 

        % fig:menu_1_design_c2
        % first UI menu to show
        \begin{figure}[!ht]
            \centering
            \includegraphics[width=.7\textwidth]{s04/design/ui1.png}
            \caption{Design for first menu}
            \label{fig:menu_1_design_c2}
        \end{figure}

        A change I have made in \autoref{fig:menu_2_design_c2} compared to \autoref{fig:menu_1_design_c2} is moving the `Cancel' button to the bottom left corner instead of keeping it in the bottom right corner. 
        I decided this was better as it stayed consistent with the previous cycle, see \autoref{fig:installer_gui_design_c1}, and that that is how people tend to read (the order being top left, top right, bottom left, bottom right, according to \href{https://www.interaction-design.org/literature/article/visual-hierarchy-organizing-content-to-follow-natural-eye-movement-patterns}{the Interaction Design Foundation}). 
        As part of my reflection from the first cycle, I have decided to include a `Browse' button, which will allow the user to select a directory using the familiar user interface of their operating system, as opposed to being forced to type in their directory manually. 
        This is better as it increases usability. 

        % \clearpage
        % fig:menu_2_design_c2
        % design for opening a menu 
        \begin{figure}[!ht]
            \centering
            \includegraphics[width=.7\textwidth]{s04/design/ui2_open_existing.png}
            \caption{Design for opening an existing project}
            \label{fig:menu_2_design_c2}
        \end{figure}

        % \newpage
        In \autoref{fig:init_new_proj_ui_design_c2}, I have designed the user interface for initialising a new project. The user will be allowed to select the name of the project and the directory in which the project is stored. I have also decided to include a dropdown selection box that would allow the user to select the "type" of project. 
        At this time, I am not certain of what that exactly refers to. 
        However, in the future I could use it for something. 
        For example, the user being able to choose from a selection of pre-made circuits as a demonstration of the software.

        % fig:init_new_proj_ui_design_c2
        % design for the ui for initialising a new project
        \begin{figure}[!ht]
            \centering
            \includegraphics[width=.7\textwidth]{s04/design/ui2_init_new_proj.png}
            \caption{Design for initialising a new project}
            \label{fig:init_new_proj_ui_design_c2}
        \end{figure}

        Following the menu from \autoref{fig:menu_2_design_c2} and \autoref{fig:init_new_proj_ui_design_c2}, the user will be taken to the main program, which will be taken on in a separate cycle.


    \subsection{Algorithms}
        % I'll need an algorithm for "opening" a project. i.e. passing off a directory as an argument to another function.
        % I'll need an algorithm to initiate a configuration file
        % I'll also need to think about how I will be able to lead from one UI element to another, something like this https://stackoverflow.com/questions/19473072/show-another-ui-file-on-button-click

        For this cycle I have decided to plan some key algorithms. 
        These include algorithms to initiate a configuration file, opening a project, and updating the queue-like data structure.

        % pc:init_config_file_c2
        % Pseudocode to initiate the configuration file in a project folder from UI
        \begin{figure}[!ht]
            \begin{minted}[linenos]{python}
import json

def create_config_file():
    dictionary = {
        "directory": ent_directory.text,
        "project_name": ent_name.text,
        "type": drop_type.text,
        "created": UNIX(),
        "last_opened": UNIX()
    }

    with open("config.json") as file:
        json.dumps(dictionary, file)
            \end{minted}
            \caption{Pseudocode to initiate configuration file}
            \label{pc:init_config_file_c2}
        \end{figure}


        % Opening a project

        % Updating Queue 

        \newpage

        % pc:fileq-length-method
        % PC for length of the file queue
        \begin{figure}[!ht]
            \begin{minted}[linenos]{python}
def length(self):
    return self.rear - self.front + 1
            \end{minted}
            \caption{Pseudocode to return the length of the FileQueue}
            \label{pc:fileq-length-method}
        \end{figure}

        Note that in \autoref{fig:file-q-class-diagram} the \verb|length()| method is not a getter, as there is no length attribute defined in the class, which may be different to other implementations. 
        For example in Python where \verb|len()| is an in-built function that takes in any iterable object, or in JavaScript where \verb|length| is an attribute. 
        This method will mostly be used in order make some checks for the other functions in order to catch some edge cases. 

        % pc:enq-for-file-q
        % Code to enqueue to file queue
        \begin{figure}[!ht]
            \begin{minted}[linenos]{python}
def enqueue(self, project_id):
    # if the queue is full
    if self.length() == self.maxLength:
        self.front += 1

    self.rear += 1

    file = open(self.location)
    file.write(project_id)
    file.close()
            \end{minted}
            \caption{Pseudocode to add project to a FileQueue}
            \label{pc:enq-for-file-q}
        \end{figure}

        In \autoref{pc:enq-for-file-q}, the amount of items in the queue is checked in order to make sure the pointers are changed properly. 
        For example an edge case that could be considered is when an item is added to the FileQueue and there is no need to remove the oldest item as the FileQueue is not full, illustrated in \autoref{flow:fileq-not-full}.

        % flow:fileq-not-full
        % FileQueue when not full
        \begin{figure}[!ht]
            \centering
            \begin{tikzpicture}[node distance=2cm]
                \node (1) [process, align=center, ] {A};
                \node (2) [process, right of=1, align=center, xshift=2.0cm] {B};

                \node (3) [process, below of=1, align=center, ] {A};
                \node (4) [process, below of=2, align=center, ] {B};
                \node (5) [process, right of=4, align=center, xshift=2.0cm] {C};

                \draw[arrow] (2) -- (1);

                \draw[arrow] (4) -- (3);
                \draw[arrow] (5) -- (4);

            \end{tikzpicture}
            \caption{Desired FileQueue behaviour when not at maxLength. C is added without A being removed.}
            \label{flow:fileq-not-full}
        \end{figure}

        Essentially, the \verb|front| pointer is only incremented whenever the FileQueue is already at maximum capacity.

        % flow:fileq-deq-method
        % Deq method flowchart
        \begin{figure}[!ht]
            \centering
            \begin{tikzpicture}[node distance=2cm, scale=0.4]
                \node (start) [startstop] {Start};
                \node (len) [decision, below of=start, align=center, yshift=-1cm] {self.length()\\== 0};
                \node (except) [process, right of=len, align=center, xshift=2cm] {Raise Exception};
                \node (end1) [startstop, right of=except, align=center, xshift=2cm] {End};

                \node (open) [process, below of=len, align=center, yshift=-1cm] {Open file};
                \node (get) [process, below of=open, align=center, ] {value = item\\at front pointer};
                \node (close) [process, below of=get, align=center, ] {Close file};
                
                \node (return) [io, below of=close, align=center, ] {Return value};
                \node (end2) [startstop, below of=return, align=center, ] {End};

                \draw[arrow] (start) -- (len);
                \draw[arrow] (open) -- (get);
                \draw[arrow] (get) -- (close);
                \draw[arrow] (close) -- (return);
                \draw[arrow] (return) -- (end2);
                \draw[arrow] (except) -- (end1);
                
                \draw[arrow] (len) -- node[anchor=north] {Yes} (except);
                \draw[arrow] (len) -- node[anchor=west] {No} (open);
            \end{tikzpicture}
            \caption{Flowchart for dequeue method}
            \label{flow:fileq-deq-method}
        \end{figure}

        \newpage

\section{Testing}
    See \autoref{tbl:test-data-cycle2}.

    \newpage
\section{Implementation}

    \subsection{CSV2LaTeX}
        % Include a screenshot of the GUI please
        In the middle of creating \autoref{tbl:test-data-cycle2}, I found it very tedious to type in the data manually straight into \LaTeX code, which prompted me to consider other methods. 
        Since I find the user interface of Microsoft Excel quite easy to work with and well suited to manipulating tabular data, as well as CSV files easy to manipulate in Python, I wrote a Python script (including GUI) that would take in a CSV file and output a formatted table in \LaTeX. 

        % pc:csv2latex-example-input-csv
        % Example input CSV file
        \begin{figure}[!ht]
            \begin{minted}[linenos]{text}
This,is,a,test
hello,world,foo,bar
1,2,3,4
words,words,words,words
            \end{minted}
            \caption{Example input CSV file. The top row includes the table headers.}
            \label{pc:csv2latex-example-input-csv}
        \end{figure}


        % pc:csv2latex-example-output-latex
        % Example LaTeX table output
        \begin{figure}[!ht]
            \begin{minted}[linenos]{latex}
% tbl:example-for-nea
% Example table
\begin{table}[!ht]
    \centering
    \begin{tabular}{@{}llll@{}} \toprule
        \textbf{This} & \textbf{is} & \textbf{a} & \textbf{test} \\ \midrule 
        hello & world & foo & bar \\ 
        1 & 2 & 3 & 4 \\ 
        words & words & words & words \\ 
        \bottomrule
    \end{tabular}
    \caption{This is what an example table looks like}
    \label{tbl:example-for-nea}
\end{table}
            \end{minted}
            \caption{Example LaTeX code output}
            \label{pc:csv2latex-example-output-latex}
        \end{figure}


        % fig:rendered-csv2latex-table
        % Rendered LaTeX table
        \begin{figure}[!ht]
            \centering
            \includegraphics[scale=.25]{s04/implement/example-tbl.png}
            \caption{The rendered LaTeX code}
            \label{fig:rendered-csv2latex-table}
        \end{figure}

        First I wrote a function to work from a CSV file and write the \LaTeX code from there, shown in \autoref{sc:csv2latex-func}. 
        It takes in the path to the CSV input file, the desired label, caption, and title, and whether the CSV file includes the table headers or not. 
        Using that, I formatted the data from the CSV file by following \LaTeX code I had previously written. 
        This function returns the \LaTeX code as a string, not yet writing it to an output text file. 

        Working with just this function within a Python file would have been fine, however in order to account for maintainability, I tried to make it as easy as possible for people other than me to create new tables, taking into consideration that \LaTeX is specialist knowledge. 
        For example in the case where multiple people are working on the documentation, they should use the same table formatting in order to stay consistent. 
        This prompted me to develop a GUI front-end to the script, shown in \autoref{fig:csv2latex-gui}.

        I again decided to use a class for the main GUI element and implement button functionality as methods of the class, the constructor of the class (where labels, entries, and buttons are defined) are shown in \autoref{sc:csv2latex-gui-init-1}, \autoref{sc:csv2latex-gui-init-2}, and \autoref{sc:csv2latex-gui-init-3}. 
        I had also defined the \verb|input| and \verb|output| attributes, which are the input and output file paths respectively. 

        Inspired by the previous implementation in Cycle 1, a browse button was added, the method for which is shown in \autoref{sc:csv2latex-browse-method}, this allows for the functionality of converting a CSV file from anywhere on the user's computer.

        Another quality of life feature that I decided to implement is making the script accessible from a command line. 
        The Python script is installed as a pip module, pip being the library manager for Python, making it callable from a command line as pip makes sure to add the correct files to the PATH environmental variable.  
        The user is able to type \verb|csv2latex [input] [caption] [label]| and the program will work the same as if from the GUI. 
        The code to handle arguments from the command line is shown in \autoref{sc:csv2latex-cli}.
        This makes the script faster to use, as although the GUI is easy to use, it is slower as there are more steps to using it, also since the terminal is accessible from within most IDEs, it makes it very easy to create \LaTeX tables quickly while editing the document. 
        An example of the CLI version being used is shown in \autoref{pc:csv2latex-cli-output}.

        The main purpose for this script is to increase maintainability of the project. 
        Since the documentation is written in \LaTeX, which is a tool that not everyone may have experience with, a dedicated tool to convert easy-to-work-with CSV tables into \LaTeX code would be very useful. 
        A theoretical use case for this tool (which has not been fully implemented in this project, due to particular way that column widths work in \LaTeX) is keeping a folder full of CSV files that each get converted to \LaTeX files, and then using the built-in \LaTeX command \verb|\input|, which essentially directly copies the contents of the referenced file into the file it was called in at compilation time. 
        This would mean that the \LaTeX code for the table would never have to be seen by the user, as after editing the CSV file, they would only have to call the tool from the command line and the document would update accordingly.
        The issue of column widths could be accounted for by reserving a record of the CSV file to specify the width of each column, but it is highly unlikely that the user would know what the best column widths be without literally checking until it looks `about right'. 
        I suppose that an algorithm that would be `good enough' in most cases definitely exists, but I think that the user would have to fine-tune the result either way, so I don't think that this feature is worth implementing.

        % pc:csv2latex-cli-output
        % Example CSV2LaTeX CLI output
        \begin{figure}[!ht]
            \begin{minted}[linenos]{text}
>csv2latex tables\forces.csv "The four fundamental forces" fundamental-forces
Successfully written to 'tables\forces.tex'
            \end{minted}
            \caption{Example CSV2LaTeX CLI output}
            \label{pc:csv2latex-cli-output}
        \end{figure}

        % fig:csv2latex-gui
        % GUI for CSV2LaTeX
        \begin{figure}[!ht]
            \centering
            \includegraphics[width=.7\textwidth]{s04/implement/csv2latex-gui.png}
            \caption{GUI for CSV2LaTeX}
            \label{fig:csv2latex-gui}
        \end{figure}
        
    
    \subsection{FileQueue Class}
        I decided to implement the FileQueue first, as it was more standalone than the Project class and so better to do first. 

        % \vspace{10pt}
        The constructor method for the FileQueue is shown in \autoref{sc:fileq-constructor}. 
        The attributes have remained the same as in the design, shown in \autoref{fig:file-q-class-diagram}, \verb|__maxLength| and \verb|__location| are defined from the parameters, and \verb|rear| and \verb|front| are first defined as 0. 

        Since the items in the FileQueue are read from a source text file, it follows that the initial values for the front and rear pointers depend on the state of the source at the time of initialisation. 
        This only affects the front pointer, as the rear pointer always points to the last item in the source. 

        % flow:fileq-front-ptr-init-bad
        % Showing how the front pointer gets initialised
        \begin{figure}[!ht]
            \centering
            \begin{tikzpicture}[node distance=2cm]
                \node (1) [process, align=center, ] {A (Non-existent)};
                \node (2) [process, right of=1, align=center, xshift=2.0cm] {B};
                \node (3) [process, right of=2, align=center, xshift=2.0cm] {C};
                \node (4) [process, right of=3, align=center, xshift=2.0cm] {D};

                \node at (0, -1.3) {-1};
                \node at (4, -1.3) {0};
                \node at (8, -1.3) {1};
                \node at (12, -1.3) {2};

                \node at (12, 1.3) {rear};
                \node at (0, 1.5) {rear - maxLength + 1};
                \node at (0, 1.1) {(Wrong)};

                \draw[arrow] (4) -- (3);
                \draw[arrow] (3) -- (2);
                \draw[arrow] (2) -- (1);
                \draw[dashed] (2,-1.5) -- (2,1.7);
            \end{tikzpicture}
            \caption{How the front pointer could be wrongly initialised}
            \label{flow:fileq-front-ptr-init-bad}
        \end{figure}

        \autoref{flow:fileq-front-ptr-init-bad} shows how the front pointer could be mistakenly initialised to a negative value if the source has not yet got \verb|maxLength| items, which would cause unwanted behaviour later (in Python, accessing the $n$th index, where $n$ is negative, results in the $n$th to last item being returned, i.e. not raise an exception, which would make it hard to debug). 
        Similar precautions were taken when implementing the enqueue method (the front pointer need not be decremented if the FileQueue has not reached \verb|maxLength|).

        % \vspace{10pt}
        Since the behaviour of other methods depended on the amount of items in the FileQueue, the length method was the first to be implemented, shown in \autoref{sc:fileq-length-method}. 
        It is only one line, and returns the amount of items calculated with the front and rear pointers. 


        % DEQUEUE METHOD

        % \vspace{10pt}
        The next method to be implemented was the dequeue method, shortened to \verb|deq| as it was easier to type, the code for which is shown in \autoref{sc:fileq-deq-method}. 
        The first thing to check is the current length of the FileQueue; you can't remove items from an empty queue. 
        The method raises a generic exception with a message explaining what happened, which I deemed descriptive enough to help in future debugging and maintainability.

        Next the method accesses the value located at the rear pointer and sets it to a variable to be returned later. 
        I have decided to use a Python \verb|with| statement to access the file, as it is safer than the usual \verb|file.open()| and \verb|file.close()|. 
        With statements will automatically close the file and manage resources, whereas without it if an exception occurs before the closing statement is processed, the file will not close safely, which could lead to unwanted behaviour in the future. 

        % \vspace{10pt}
        Notice that at no point is the item actually deleted from the text file, the front pointer is incremented to simulate this, and it saves on having to think about working with text files further. 
        One obvious downside to this implementation is that the source file will keep growing and taking up storage, however this will not be a big issue. 

        % \vspace{10pt}
        Assuming an average file path length of $l$ characters and the text file having $n$ lines the formula to calculate how much storage space $S$ it would use is as follows
        \begin{align*}
            8ln &= S \\
            \implies n &= \frac{S}{8l}
        \end{align*}
        % Do a calculation to show why it isn't an issue. 
        I wrote a Python script to find the average length of a file path on my computer, see \autoref{sc:avg-filepath-length-file}, which gave the output shown in \autoref{fig:avg-filepath-output}. 
        I will use the value $123.37202$ as my value for $l$. 

        % fig:avg-filepath-output
        % Output from avg filepath script
        \begin{figure}[!ht]
            \begin{minted}[linenos]{text}
Total files: 995122
Total length: 122770209
Average: 123.37202
Time taken: 4.143689362208049 min
            \end{minted}
            \caption{Output from the script}
            \label{fig:avg-filepath-output}
        \end{figure}

        According to the Steam hardware survey, most computer users have over 1 \si{TB} of storage available, so using 0.5\% of that for $S$ is reasonable. 

        % fig:steam-hw-survey-storage
        % Steam hardware survey results regarding storage
        \begin{figure}[!ht]
            \centering
            \includegraphics[width=.7\textwidth]{s04/implement/steam-hardware-survey-storage.png}
            \caption{Steam hardware survey results regarding storage}
            \label{fig:steam-hw-survey-storage}
        \end{figure}

        This means that to use up 5 \si{GB} of storage, the file would have to be written to almost 5.1 million times, which is clearly far beyond a reasonable amount. 
        Thus, I conclude that the contents of the file never being deleted would not be an issue to the average user, but in the case that it is, the user is welcome to remove the contents manually. 


        % ENQUEUE METHOD

        % \vspace{10pt}
        The method that was implemented next was the enqueue method, again shortened to \verb|enq| as it was easier to type, the code for which is shown in \autoref{sc:fileq-enq-method}. 

        The method takes in a string, which is the ID code or directory of a project, and the first thing that happens is the string being written to the file stored at \verb|__location|. 
        A newline character is also written to make sure that they're written to different lines. 

        When an item is enqueued, the pointers need to be correctly adjusted, and whether the \verb|front| pointer gets incremented depends on if the FileQueue is full. 
        The code is commented in order to explain why and when which pointers are incremented. 


        % DROP METHOD 

        % \vspace{10pt}
        The final method for this class was \verb|drop|, the code for which is shown in \autoref{sc:fileq-drop-method-final}. 
        In order to save resources, the method checks the length before opening the text file and returns an empty list if the length is zero. 

        There were originally issues with this method, and the original code is shown in \autoref{sc:fileq-drop-method-og}. 
        Firstly, the arguments passed to the for-loop were incorrect, which resulted in not all the items being printed. 
        However, the bigger issue stemmed from calling \verb|file.readlines()| at every iteration. 

        % pc:mult-readlines-showcase-bad
        % Outcome of repeatedly calling the readlines method
        \begin{figure}[!ht]
            \begin{minted}[linenos]{python}
>>> name = "test.txt"
>>> # 'test.txt' contains names of some countries
>>> with open(name, "r") as file:
...     for i in range(5):
...             print(file.readlines())
... 
['England\n', 'Spain\n', 'France\n', 'Germany\n', 'Poland\n']
[]
[]
[]
[] 
            \end{minted}
            \caption{Outcome of repeatedly calling the `readlines' method}
            \label{pc:mult-readlines-showcase-bad}
        \end{figure}

        % fig:drop-method-original-bad-1
        % Result of original drop method
        \begin{figure}[!ht]
            \centering
            \includegraphics[width=.7\textwidth]{s04/implement/drop-method-bad-1.png}
            \caption{Result of original drop method}
            \label{fig:drop-method-original-bad-1}
        \end{figure}

        As shown in \autoref{pc:mult-readlines-showcase-bad}, calling \verb|readlines| multiple times resulted in an empty list as opposed to a list of every line in the file, and that lead to empty lists being returned from the method, shown in \autoref{fig:drop-method-original-bad-1}.


        After fixing these issues, the expected outcome was seen, shown in \autoref{fig:drop-method-good-output}.

        % fig:drop-method-good-output
        % Drop method successfully outputting items
        \begin{figure}[!ht]
            \centering
            \includegraphics[width=.7\textwidth]{s04/implement/drop-method-good.png}
            \caption{Drop method successfully outputting items}
            \label{fig:drop-method-good-output}
        \end{figure}

    \subsection{Project Class}
        The immediate issue that made itself apparent was that there weren't any projects to populate the JSON files. Despite this, the implementation continued as far as it could in this cycle, and shortcomings will be addressed in the evaluation of this cycle. 

        The first method written for this class was the constructor, shown in \autoref{sc:project-init}. 
        Note that the input parameters to the \verb|__init__| method have the same identifiers as the ones shown in \autoref{ps:json-proj-config-example}, this is so that the JSON file can be used to initialise a class in a much simpler way through the use of key word arguments, evidence of which is shown in \autoref{fig:project-class-read-from-file}.
        Then the attributes for the class are defined from the inputs, as well as the attribute \verb|maxNameLength| defined to be 32 as described in the design. 
        The validation for the inputs were omitted from the constructor of the class, as it was decided to factor that in with the user interface for inputting the data. 

        % fig:project-class-read-from-file
        % Project class reading from JSON file
        \begin{figure}[!ht]
            \centering
            \includegraphics[width=0.7\textwidth]{s04/implement/project-read-from-file.png}
            \caption{Project class reading from JSON file}
            \label{fig:project-class-read-from-file}
        \end{figure}

        % Name parameter
        The next methods to be written were regarding the \verb|__name| parameter, which is declared as private. This means that the getter and setter methods had to be written, and the setter here includes validation, as shown in \autoref{sc:project-name-setter}. 
        An error message is written to the variable \verb|err|, describing the fact that the desired input exceeds the maximum length, and then if the length does exceed the limit then an exception is raised, which terminated the method there. 
        If no exception is raised, then the method correctly sets the \verb|__name| attribute to the input string \verb|name|.
        The variable \verb|err| could have been declared within the \verb|if| statement, as the outcome would be the same, and the reason that it wasn't was so that it would fit on the page width-wise inside this documentation. 
        A getter for this attribute was also written, see \autoref{sc:project-name-getter}, and it simply returns the value of the attribute.
        Evidence for both of these methods working is shown in \autoref{fig:project-name-getter-setter-pf}.
        Notice that this method includes a docstring (documentation string) including formatting, which describes the function of the setter as well as describing which exception is raised at which conditions.
        This was written in order to aid maintainability as well as improve the programming experience, as the programmer will not have to go back and forth to see how exactly the method operates. 
        This is the case for all methods for this class. 

        % fig:project-name-getter-setter-pf
        % Project name attribute getter and setter working
        \begin{figure}[!ht]
            \centering
            \includegraphics[width=0.7\textwidth]{s04/implement/project-name-setter-getter-pf.png}
            \caption{Project name attribute getter and setter working}
            \label{fig:project-name-getter-setter-pf}
        \end{figure}

        % lastSaved
        The next methods that were written were the setters and getters for the \verb|lastSaved| method, which was also declared private. 
        The setter, shown in \autoref{sc:project-lastsaved-setter}, sets the attribute to be equal to the current time (given as time to the nearest second since 1970-01-01). 
        This is a useful format for the time to be in, since it is independent of location on the globe (unlike say, local time), which means that developers from multiple places on Earth can agree on what the time is, as well as being in an easy format to manipulate and store. 
        The getter, shown in \autoref{sc:project-lastsaved-getter}, returns the value of the attribute. 
        Evidence for both of these methods working is shown in \autoref{fig:project-lastsaved-getter-setter-pf}.

        % fig:project-lastsaved-getter-setter-pf
        % Project lastSaved attribute getter and setter working
        \begin{figure}[!ht]
            \centering
            \includegraphics[width=0.7\textwidth]{s04/implement/project-lastsaved-setter-getter-pf.png}
            \caption{Project lastSaved attribute getter and setter working}
            \label{fig:project-lastsaved-getter-setter-pf}
        \end{figure}

        The getters for the \verb|type| and \verb|created| private attributes, shown in \autoref{sc:project-type-getter} and \autoref{sc:project-created-getter} respectively, were identical to the getter for the previous attribute. 
        These attributes also did not have a setter method available, as they are only declared once at the start and are essentially constant. 


        % ZIP export method
        % Get evidence of this working
        The final method that could be written for this class, as other methods depended on functionality from aspects of the software that have not yet been written, is the code to export the project as a ZIP archive, which is shown in \autoref{sc:project-export-method}. 
        For this method, the `shutil' library was used in order to create the ZIP archive from the directory associated with the Project object and save it to a given directory, which is one a user will be able to choose from a user interface developed later.
        
    \subsection{User Interface}

        % Oops I completely forgot about the user interface. 
        % There are 3 UI windows
        % `Fork' menu - will lead to the other two
        %       - `Existing' menu - will open an existing project
        %       - `New' menu - will open a new project
        % 
        % I will need to look into how this works with this library, maybe they have a way of implementing linked UI

        % fig:open-project-gui
        % Open project GUI
        \begin{figure}[!ht]
            \centering
            \includegraphics[width=0.7\textwidth]{s04/implement/open-project-gui.png}
            \caption{Open project GUI}
            \label{fig:open-project-gui}
        \end{figure}

        With experience gained from working with the `Tkinter' library in Cycle 1 of this project, there were many small changes to how the GUI was coded in this cycle. 
        
        The object-oriented approach was maintained, keeping buttons and other elements as attributes and assigning functions to buttons through methods of the class. As shown in \autoref{sc:fork-gui-constructor}, constants are defined before the definition of the class. 
        These are used in order to more systematically change the appearance of the GUI, being able to change the values of a few parameters has made it easier to get the GUI looking as outlined in the design stage. 
        The code for initialising and placing the `general' buttons (`Cancel', etc.) is shown in \autoref{sc:fork-gui-general-buttons}, and the code to initialise and place the `dynamic' buttons is shown in \autoref{sc:fork-gui-dynamic-buttons}. 
        The dynamic buttons are named so as their text and function changes depending on what the most recent projects were, which will be integrated with the FileQueue class written previously. 

        % I have not yet implemented this because I have no wifi
        
        % fig:create-new-project-gui
        % GUI for creating a new project
        \begin{figure}[!ht]
            \centering
            \includegraphics[width=.7\textwidth]{s04/implement/new-project-gui.png}
            \caption{GUI for creating a new project}
            \label{fig:create-new-project-gui}
        \end{figure}

        Next the GUI for creating a new project was implemented, the result of which is shown in \autoref{fig:create-new-project-gui}.
        Once again, an object-oriented approach for the GUI was used, and the constructor for this class is shown in \autoref{sc:createnew-gui-construct}, \autoref{sc:createnew-gui-entries-labels}, and \autoref{sc:createnew-gui-buttons-init}.

        The code for the `Cancel' button is shown in \autoref{sc:createnew-gui-cancel-method}, which exits the GUI, and the code for the `Browse' button is shown in \autoref{sc:createnew-gui-browse-method}, which allows the user to select the directory they would like to use for their project.
        The latter is shown working in \autoref{fig:createnew-browse-button-working}.

        % fig:createnew-browse-button-working
        % `Browse' button working
        \begin{figure}[!ht]
            \centering
            \includegraphics[width=.7\textwidth]{s04/implement/browse-button-evidence.png}
            \caption{`Browse' button working}
            \label{fig:createnew-browse-button-working}
        \end{figure}

        It was decided to include input validation inside the method for the `Create' button, as that is when the data needs to be validated. 
        The functions for validating were also moved to a separate file and kept as functions, which themselves raise exceptions if conditions are not met.
        The functions for validating the project name and directory are shown in \autoref{sc:project-name-validation} and \autoref{sc:project-dir-validation} respectively, then the exceptions they raise are caught in \autoref{sc:createnew-gui-create-method}.
        If exceptions are raised, then the messages are shown to the user in a message box to the user. 
        Evidence of this working is shown in \autoref{fig:projectname-length-zero}, \autoref{fig:projectname-too-long}, and \autoref{fig:projectdir-validation}. 
        Something to address in the evaluation is that the user is never notified of all the errors at once, only ever one at a time. 


        % this could probably be a subfigure

        % fig:projectname-length-zero
        % Project name length zero validation
        \begin{figure}[!ht]
            \centering
            \includegraphics[width=.7\textwidth]{s04/implement/name-length-zero.png}
            \caption{Project name length zero validation}
            \label{fig:projectname-length-zero}
        \end{figure}

        % fig:projectname-too-long
        % Project name too long validation
        \begin{figure}[!ht]
            \centering
            \includegraphics[width=.7\textwidth]{s04/implement/name-too-long-good.png}
            \caption{Project name too long validation}
            \label{fig:projectname-too-long}
        \end{figure}

        % fig:projectdir-validation
        % Project directory validation
        \begin{figure}[!ht]
            \centering
            \includegraphics[width=.7\textwidth]{s04/implement/directory-validation-01.png}
            \caption{Project directory validation}
            \label{fig:projectdir-validation}
        \end{figure}


        If the code fails for a reason that the user could not influence, e.g. a logical error in the code, and it raises an exception, the user wouldn't have a way of telling if or when an exception is being raised. 
        In order to accommodate this, the code has been wrapped in a `try' statement, and if an exception occurs then it is caught and the error message is displayed in a message box to the user. 
        This makes it easier for the user to report bugs to the developers.
        Evidence of this working is shown in \autoref{fig:error-communication-working}.

        % fig:error-communication-working
        % Error communication to user working
        \begin{figure}[!ht]
            \centering
            \includegraphics[width=.7\textwidth]{s04/implement/catch-other-errors-good.png}
            \caption{Error communication to user working}
            \label{fig:error-communication-working}
        \end{figure}

        If all the user inputs pass the validation then a file `config.json' is created inside the given directory and written to. The user is notified, and the file is written to. 
        Evidence for this is shown in \autoref{fig:project-config-creation-success} and \autoref{fig:project-json-file-written-to}. 


        % Will put this in a subfigure as well 

        % fig:project-config-creation-success
        % Project configuration file successfully created
        \begin{figure}[!ht]
            \centering
            \includegraphics[width=.7\textwidth]{s04/implement/project-json-written-good.png}
            \caption{Project configuration file successfully created}
            \label{fig:project-config-creation-success}
        \end{figure}

        % fig:project-json-file-written-to
        % JSON file written to
        \begin{figure}[!ht]
            \centering
            \includegraphics[width=.7\textwidth]{s04/implement/json-file-evidence.png}
            \caption{JSON file written to}
            \label{fig:project-json-file-written-to}
        \end{figure}

        Initially, the challenge of linking two GUI elements together was anticipated, but it ended up being almost trivial. 
        After quitting from the original menu, the subsequent GUI menu is started as normal, and the method for the `Open new' button is shown in \autoref{sc:forkgui-opennew-method-final}. 
        The evidence for this working is shown in \url{https://youtu.be/iVopl7ceLng}.

        % fig:fileq-with-gui
        % FileQueue integrated with user interface
        \begin{figure}[!ht]
            \centering
            \includegraphics[width=.7\textwidth]{s04/implement/fileq-with-gui.png}
            \caption{FileQueue integrated with user interface}
            \label{fig:fileq-with-gui}
        \end{figure}

        At this point the integration with the FileQueue class was implemented into the user interface. Evidence for this working is shown in \autoref{fig:fileq-with-gui}, and the code is shown in \autoref{sc:fileq-with-gui} and \autoref{sc:buttons-with-fileq}. 
        Note that this is an updated version of \autoref{sc:fork-gui-dynamic-buttons}, meaning that the latter is not a part of the final code. 
        This implementation does seem messy as it makes use of the fact that if a list does not have an element at the index being queried then it raises an `IndexError' exception to infer how many items are in the list.

        Selecting an existing project is done through selecting the corresponding `config.json' for that project in that project's directory. 
        The code for this button is shown in \autoref{sc:forkgui-open-existing-method}. 
        Note how the `filetypes' parameter is specified, which makes sure that the user can only select files of the correct type, which eliminates the need to check for validation in terms of the file type selected. 
        There is also a check for whether a file has been selected, which makes it so that the user can cancel the file-selection dialogue without quitting the entire program. 
        Evidence for this working is shown on \url{https://youtu.be/CGXdaxBu2OI}.
    

        % I need to write the code that links the FileQueue to this UI cause otherwise that was pointless.
        % I think I will create a attribute of Fork that is an instance of FileQueue that I then access 
        
        % At this point im not sure whether scale is better than width for maintainability
        % Width is probably better now that i think about it bc it gives more consistent sizes


\section{Evaluation}
    The implementation so far is now going to be evaluated against the success criteria declared at the beginning of this cycle, shown in \autoref{tbl:succ-crit-c2}. 
    
    % I think I'm going to tweak my success criteria so that theres actually stuff to tick off/cross off, because looking back they dont seem particularly relevant to the cycle

    \subsection{Analysis of Success Criteria}
    
    \begin{itemize}
        \item B4: Being able to export and import circuit arrangements
        \begin{itemize}
            \item Not achieved
            \item This functionality has been moved to the third cycle
        \end{itemize}
        \item X1: Allow the user to create new projects easily
        \begin{itemize}
            \item Achieved
            \item The user is given a clean and clear user interface that allows them to select the directory and name of their project.
        \end{itemize}
    \end{itemize}



    % Talk about code maintainability
    % Talk about how it works well
    % Talk about things I would have done differently

    There are some points that would be improved upon were this to be taken up again. 
    For example, if the user goes to create a new directory and then presses cancel in the next GUI menu, then the user has no way to go back to open an existing project and has to open the program again from wherever they opened it from, which is slightly inconvenient. 
    This would be improved on by thinking through the logic of the program again and thinking about how the GUI menus interact with each other. 


